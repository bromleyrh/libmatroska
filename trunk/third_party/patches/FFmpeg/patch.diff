diff --git a/Makefile b/Makefile
index 61f79e27ae..dc3b0c2579 100644
--- a/Makefile
+++ b/Makefile
@@ -190,6 +190,11 @@ $(sort $(OUTDIRS)):
 %.h:
 	@:
 
+libavfilter/metal/vf_yadif_videotoolbox.metal.air:
+libavfilter/metal/vf_yadif_videotoolbox.metallib:
+libavfilter/metal/vf_yadif_videotoolbox.metallib.c:
+libavformat/matroska_codecs.c:
+
 # Disable suffix rules.  Most of the builtin rules are suffix rules,
 # so this saves some time on slow systems.
 .SUFFIXES:
diff --git a/configure b/configure
index 240ae942d1..c6ed81db48 100755
--- a/configure
+++ b/configure
@@ -245,6 +245,7 @@ External library support:
   --enable-libklvanc       enable Kernel Labs VANC processing [no]
   --enable-libkvazaar      enable HEVC encoding via libkvazaar [no]
   --enable-liblensfun      enable lensfun lens correction [no]
+  --disable-libmatroska    disable libmatroska Matroska demuxer [autodetect]
   --enable-libmodplug      enable ModPlug via libmodplug [no]
   --enable-libmp3lame      enable MP3 encoding via libmp3lame [no]
   --enable-libopencore-amrnb enable AMR-NB de/encoding via libopencore-amrnb [no]
@@ -1756,6 +1757,7 @@ EXTERNAL_AUTODETECT_LIBRARY_LIST="
     bzlib
     coreimage
     iconv
+    libmatroska
     libxcb
     libxcb_shm
     libxcb_shape
@@ -3404,6 +3406,7 @@ libxavs_encoder_deps="libxavs"
 libxavs2_encoder_deps="libxavs2"
 libxvid_encoder_deps="libxvid"
 libzvbi_teletext_decoder_deps="libzvbi"
+matroska_demuxer_deps="libmatroska"
 vapoursynth_demuxer_deps="vapoursynth"
 videotoolbox_suggest="coreservices"
 videotoolbox_deps="corefoundation coremedia corevideo"
@@ -3826,6 +3829,7 @@ swscale_suggest="libm stdatomic"
 
 avcodec_extralibs="pthreads_extralibs iconv_extralibs dxva2_extralibs lcms2_extralibs"
 avfilter_extralibs="pthreads_extralibs"
+avformat_extralibs="libmatroska_extralibs"
 avutil_extralibs="d3d11va_extralibs nanosleep_extralibs pthreads_extralibs vaapi_drm_extralibs vaapi_x11_extralibs vdpau_x11_extralibs"
 
 # programs
@@ -6604,6 +6608,7 @@ enabled libjxl            && require_pkg_config libjxl "libjxl >= 0.7.0" jxl/dec
 enabled libklvanc         && require libklvanc libklvanc/vanc.h klvanc_context_create -lklvanc
 enabled libkvazaar        && require_pkg_config libkvazaar "kvazaar >= 0.8.1" kvazaar.h kvz_api_get
 enabled liblensfun        && require_pkg_config liblensfun lensfun lensfun.h lf_db_new
+enabled libmatroska       && require_pkg_config libmatroska libmatroska matroska.h matroska_open
 
 if enabled libmfx && enabled libvpl; then
    die "ERROR: can not use libmfx and libvpl together"
diff --git a/ffbuild/common.mak b/ffbuild/common.mak
index f52473453e..02714ead49 100644
--- a/ffbuild/common.mak
+++ b/ffbuild/common.mak
@@ -14,11 +14,12 @@ ifndef SUBDIR
 
 BIN2CEXE = ffbuild/bin2c$(HOSTEXESUF)
 BIN2C = $(BIN2CEXE)
+GPERF = gperf
 
 ifndef V
 Q      = @
 ECHO   = printf "$(1)\t%s\n" $(2)
-BRIEF  = CC CXX OBJCC HOSTCC HOSTLD AS X86ASM AR LD STRIP CP WINDRES NVCC BIN2C
+BRIEF  = CC CXX OBJCC HOSTCC HOSTLD AS X86ASM AR LD STRIP CP WINDRES NVCC BIN2C GPERF
 SILENT = DEPCC DEPHOSTCC DEPAS DEPX86ASM RANLIB RM
 
 MSG    = $@
@@ -112,6 +113,9 @@ COMPILE_LASX = $(call COMPILE,CC,LASXFLAGS)
 %.h.c:
 	$(Q)echo '#include "$*.h"' >$@
 
+%.c: %.gperf
+	$(GPERF) -C $< >$@
+
 $(BIN2CEXE): ffbuild/bin2c_host.o
 	$(HOSTLD) $(HOSTLDFLAGS) $(HOSTLD_O) $^ $(HOSTEXTRALIBS)
 
diff --git a/ffbuild/library.mak b/ffbuild/library.mak
index 793e9d41fa..dea48bec7c 100644
--- a/ffbuild/library.mak
+++ b/ffbuild/library.mak
@@ -80,8 +80,8 @@ clean::
 install-lib$(NAME)-shared: $(SUBDIR)$(SLIBNAME)
 	$(Q)mkdir -p "$(SHLIBDIR)"
 	$$(INSTALL) -m 755 $$< "$(SHLIBDIR)/$(SLIB_INSTALL_NAME)"
-	$$(STRIP) "$(SHLIBDIR)/$(SLIB_INSTALL_NAME)"
-	$(Q)$(foreach F,$(SLIB_INSTALL_LINKS),(cd "$(SHLIBDIR)" && $(LN_S) $(SLIB_INSTALL_NAME) $(F));)
+	$$(STRIP) "$(SHLIBDIR)/$(SLIB_INSTALL_NAME)" && chmod 0755 "$(SHLIBDIR)/$(SLIB_INSTALL_NAME)"
+	$(Q)$(foreach F,$(SLIB_INSTALL_LINKS),(cd "$(SHLIBDIR)" && umask 022 && $(LN_S) $(SLIB_INSTALL_NAME) $(F));)
 	$(if $(SLIB_INSTALL_EXTRA_SHLIB),$$(INSTALL) -m 644 $(SLIB_INSTALL_EXTRA_SHLIB:%=$(SUBDIR)%) "$(SHLIBDIR)")
 	$(if $(SLIB_INSTALL_EXTRA_LIB),$(Q)mkdir -p "$(LIBDIR)")
 	$(if $(SLIB_INSTALL_EXTRA_LIB),$$(INSTALL) -m 644 $(SLIB_INSTALL_EXTRA_LIB:%=$(SUBDIR)%) "$(LIBDIR)")
@@ -89,7 +89,7 @@ install-lib$(NAME)-shared: $(SUBDIR)$(SLIBNAME)
 install-lib$(NAME)-static: $(SUBDIR)$(LIBNAME)
 	$(Q)mkdir -p "$(LIBDIR)"
 	$$(INSTALL) -m 644 $$< "$(LIBDIR)"
-	$(LIB_INSTALL_EXTRA_CMD)
+	$(LIB_INSTALL_EXTRA_CMD) && chmod 0644 "$(LIBDIR)/$(LIBNAME)"
 
 install-lib$(NAME)-headers: $(addprefix $(SUBDIR),$(HEADERS) $(BUILT_HEADERS))
 	$(Q)mkdir -p "$(INCINSTDIR)"
diff --git a/libavformat/.gitignore b/libavformat/.gitignore
index fb70c122c4..13663f54c4 100644
--- a/libavformat/.gitignore
+++ b/libavformat/.gitignore
@@ -1,3 +1,5 @@
 /protocol_list.c
 /muxer_list.c
 /demuxer_list.c
+
+/libmatroska_codecs.c
diff --git a/libavformat/Makefile b/libavformat/Makefile
index 5cdcda3239..01a6390153 100644
--- a/libavformat/Makefile
+++ b/libavformat/Makefile
@@ -337,6 +337,9 @@ OBJS-$(CONFIG_MATROSKA_MUXER)            += matroskaenc.o matroska.o \
                                             av1.o avc.o hevc.o \
                                             flacenc_header.o avlanguage.o \
                                             vorbiscomment.o wv.o dovi_isom.o
+OBJS-$(CONFIG_LIBMATROSKA_DEMUXER)       += libmatroska.o \
+                                            libmatroska_codecs.o \
+                                            zlib_stream.o
 OBJS-$(CONFIG_MCA_DEMUXER)               += mca.o
 OBJS-$(CONFIG_MCC_DEMUXER)               += mccdec.o subtitles.o
 OBJS-$(CONFIG_MD5_MUXER)                 += hashenc.o
@@ -740,3 +743,5 @@ TOOLS     = aviocat                                                     \
             seek_print                                                  \
             sidxindex                                                   \
             venc_data_dump
+
+TOOLS-$(CONFIG_LIBMATROSKA_DEMUXER) = mkv_decode
diff --git a/libavformat/allformats.c b/libavformat/allformats.c
index cebd5e0c67..371b605760 100644
--- a/libavformat/allformats.c
+++ b/libavformat/allformats.c
@@ -252,6 +252,7 @@ extern const AVOutputFormat ff_md5_muxer;
 extern const AVInputFormat  ff_matroska_demuxer;
 extern const AVOutputFormat ff_matroska_muxer;
 extern const AVOutputFormat ff_matroska_audio_muxer;
+extern const AVInputFormat  ff_libmatroska_demuxer;
 extern const AVInputFormat  ff_mgsts_demuxer;
 extern const AVInputFormat  ff_microdvd_demuxer;
 extern const AVOutputFormat ff_microdvd_muxer;
diff --git a/libavformat/libmatroska.c b/libavformat/libmatroska.c
new file mode 100644
index 0000000000..0b868070a2
--- /dev/null
+++ b/libavformat/libmatroska.c
@@ -0,0 +1,909 @@
+/*
+ * libmatroska.c
+ */
+
+#include "libmatroska_codecs.h"
+
+#include "avformat.h"
+#include "avio.h"
+#include "internal.h"
+#include "zlib_stream.h"
+
+#include "libavcodec/codec_id.h"
+#include "libavcodec/codec_par.h"
+#include "libavcodec/defs.h"
+#include "libavcodec/packet.h"
+
+#include "libavutil/avutil.h"
+#include "libavutil/dict.h"
+#include "libavutil/error.h"
+#include "libavutil/mem.h"
+#include "libavutil/opt.h"
+#include "libavutil/rational.h"
+#include "libavutil/version.h"
+
+#include <matroska.h>
+
+#include <errno.h>
+#include <inttypes.h>
+#include <limits.h>
+#include <regex.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <string.h>
+
+struct stream_ctx {
+    int comp_algo;
+};
+
+struct libmatroska_demux_ctx {
+    const AVClass   *class;
+    AVFormatContext *s;
+    AVStream        *cur_st;
+    AVPacket        *pkt;
+    matroska_hdl_t  hdl;
+    regex_t         id_regex;
+    AVRational      ts_scale;
+    int64_t         duration;
+    int             pdim[2];
+    int             ddim[2];
+    char            *title;
+    char            *buf;
+    int64_t         pkt_duration;
+    size_t          len;
+    size_t          off;
+    uint64_t        base_ts;
+    AVBufferRef     *st_data;
+    size_t          num_st;
+    size_t          tot_bytes[3];
+    int             debug;
+};
+
+struct zlib_ctx {
+    AVPacket    *pkt;
+    AVBufferRef *buf;
+    size_t      len;
+    size_t      sz;
+};
+
+typedef int metadata_handler_t(matroska_metadata_t *, size_t,
+                               struct libmatroska_demux_ctx *);
+
+#ifndef NDEBUG
+#define DEBUG_OUTPUT
+#endif
+
+static const AVOption libmatroska_demuxer_options[] = {
+    {
+        .name          = "debug",
+        .help          = "enable debugging features",
+        .offset        = offsetof(struct libmatroska_demux_ctx, debug),
+        .type          = AV_OPT_TYPE_INT,
+        .default_val   = {.i64 = 0},
+        .min           = 0,
+        .max           = 1,
+        .flags         = AV_OPT_FLAG_DECODING_PARAM
+    },
+    {NULL}
+};
+
+static const AVClass libmatroska_demuxer_class = {
+    .class_name = "libmatroska demuxer",
+    .item_name  = av_default_item_name,
+    .option     = libmatroska_demuxer_options,
+    .version    = LIBAVUTIL_VERSION_INT
+};
+
+#define MATROSKA_TYPE_MASTER 0
+
+#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
+
+#ifdef DEBUG_OUTPUT
+#define debug_printf(fmt, ...) fprintf(stderr, fmt, __VA_ARGS__)
+#else
+#define debug_printf(fmt, ...)
+#endif
+
+#define PLURAL(val, suffix) ((val) == 1 ? "" : suffix)
+
+static unsigned hash_str(const void *, size_t);
+static unsigned hash_id(const char *);
+
+static int io_open(void **, int, void *);
+static int io_close(void *);
+static int io_read(void *, void *, int64_t *);
+static int io_get_fpos(void *, int64_t *);
+
+static void adjust_ar(struct libmatroska_demux_ctx *);
+
+static int handle_dimension(matroska_metadata_t *, int *, int,
+                            struct libmatroska_demux_ctx *);
+
+static metadata_handler_t handle_TimestampScale;
+static metadata_handler_t handle_Duration;
+static metadata_handler_t handle_Title;
+static metadata_handler_t handle_Timestamp;
+static metadata_handler_t handle_TrackNumber;
+static metadata_handler_t handle_TrackType;
+static metadata_handler_t handle_DefaultDuration;
+static metadata_handler_t handle_CodecID;
+static metadata_handler_t handle_CodecPrivate;
+static metadata_handler_t handle_PixelWidth;
+static metadata_handler_t handle_PixelHeight;
+static metadata_handler_t handle_DisplayWidth;
+static metadata_handler_t handle_DisplayHeight;
+static metadata_handler_t handle_SamplingFrequency;
+static metadata_handler_t handle_Channels;
+
+static matroska_metadata_output_cb_t metadata_cb;
+static matroska_bitstream_output_cb_t bitstream_cb;
+
+static int zlib_stream_cb(const void *, size_t, void *);
+
+static int libmatroska_read_probe(const AVProbeData *);
+static int libmatroska_read_header(struct AVFormatContext *);
+static int libmatroska_read_packet(struct AVFormatContext *, AVPacket *);
+static int libmatroska_read_close(struct AVFormatContext *);
+
+#ifdef NO_TIMESTAMPS
+#define FLAG_NOTIMESTAMPS AVFMT_NOTIMESTAMPS
+#else
+#define FLAG_NOTIMESTAMPS 0
+#endif
+
+const AVInputFormat ff_libmatroska_demuxer = {
+    .name           = "libmatroska",
+    .long_name      = NULL_IF_CONFIG_SMALL("Matroska (libmatroska)"),
+    .priv_class     = &libmatroska_demuxer_class,
+    .flags          = FLAG_NOTIMESTAMPS,
+    .read_probe     = &libmatroska_read_probe,
+    .read_header    = &libmatroska_read_header,
+    .read_packet    = &libmatroska_read_packet,
+    .read_close     = &libmatroska_read_close
+};
+
+#define UNSIGNED_BIT (sizeof(unsigned) * CHAR_BIT)
+
+static unsigned
+hash_str(const void *str, size_t len)
+{
+    const char *s = str;
+    unsigned i, ret = 0;
+
+    if (len == (size_t)-1) {
+        for (i = 0; s[i] != '\0'; i++) {
+            ret = ret << 9 | ret >> (UNSIGNED_BIT - 9);
+            ret += (unsigned)s[i];
+        }
+    } else {
+        for (i = 0; i < len && s[i] != '\0'; i++) {
+            ret = ret << 9 | ret >> (UNSIGNED_BIT - 9);
+            ret += (unsigned)s[i];
+        }
+    }
+
+    return ret == 0 ? ~0u : ret;
+}
+
+#undef UNSIGNED_BIT
+
+static unsigned
+hash_id(const char *id)
+{
+    unsigned h1, h2, h3 = 0;
+
+    h1 = hash_str(id, (size_t)-1);
+    h2 = (h1 & 30) >> 1;
+
+    switch (h2) {
+    case 9:
+        h3 = (h1 & 1) << 4;
+        break;
+    case 12:
+        h3 = (h1 & 768) >> 4;
+        /* fallthrough */
+    default:
+        break;
+    }
+
+    return h2 | h3;
+}
+
+static int
+io_open(void **ctx, int ro, void *args)
+{
+    (void)ro;
+
+    *ctx = args;
+    return 0;
+}
+
+static int
+io_close(void *ctx)
+{
+    (void)ctx;
+
+    return 0;
+}
+
+static int
+io_read(void *ctx, void *buf, int64_t *nbytes)
+{
+    AVIOContext *s = ctx;
+    int ret;
+
+    ret = avio_read(s, buf, *nbytes);
+    if (ret < 0) {
+        if (ret != AVERROR_EOF)
+            return -EIO;
+        *nbytes = 0;
+    } else
+        *nbytes = ret;
+
+    return 0;
+}
+
+static int
+io_get_fpos(void *ctx, int64_t *offset)
+{
+    AVIOContext *s = ctx;
+    int64_t ret;
+
+    ret = avio_tell(s);
+    if (ret < 0)
+        return -EIO;
+
+    *offset = ret;
+    return 0;
+}
+
+static void
+adjust_ar(struct libmatroska_demux_ctx *ctx)
+{
+    AVRational *ar;
+
+    if (ctx->pdim[0] == -1 || ctx->pdim[1] == -1 || ctx->ddim[0] == -1
+        || ctx->ddim[1] == -1)
+        return;
+
+    ar = &ctx->cur_st->sample_aspect_ratio;
+
+    av_reduce(&ar->num, &ar->den, ctx->ddim[0] * ctx->pdim[1],
+              ctx->ddim[1] * ctx->pdim[0], INT_MAX);
+}
+
+static int
+handle_dimension(matroska_metadata_t *val, int *dim, int which,
+                 struct libmatroska_demux_ctx *ctx)
+{
+    AVCodecParameters *codecpar;
+    int *d;
+
+    codecpar = ctx->cur_st->codecpar;
+    d = which == 0 ? &codecpar->width : &codecpar->height;
+    *d = dim[which] = val->uinteger;
+    adjust_ar(ctx);
+
+    return 0;
+}
+
+static int
+handle_TimestampScale(matroska_metadata_t *val, size_t len,
+                      struct libmatroska_demux_ctx *ctx)
+{
+    (void)len;
+
+    ctx->ts_scale.num = val->uinteger;
+    ctx->ts_scale.den = 1000000000;
+
+    return 0;
+}
+
+static int
+handle_Duration(matroska_metadata_t *val, size_t len,
+                struct libmatroska_demux_ctx *ctx)
+{
+    (void)len;
+
+    ctx->duration = val->dbl;
+
+    return 0;
+}
+
+static int
+handle_Title(matroska_metadata_t *val, size_t len,
+             struct libmatroska_demux_ctx *ctx)
+{
+    char *title;
+
+    (void)len;
+
+    title = strdup(val->data);
+    if (title == NULL)
+        return -errno;
+
+    free(ctx->title);
+    ctx->title = title;
+
+    return 0;
+}
+
+static int
+handle_Timestamp(matroska_metadata_t *val, size_t len,
+                 struct libmatroska_demux_ctx *ctx)
+{
+    (void)len;
+
+    ctx->base_ts = val->uinteger;
+
+    debug_printf("Timestamp %" PRIu64 "\n", ctx->base_ts);
+
+    return 0;
+}
+
+static int
+handle_TrackNumber(matroska_metadata_t *val, size_t len,
+                   struct libmatroska_demux_ctx *ctx)
+{
+    AVStream *st;
+    size_t stream_index;
+    struct stream_ctx *sctx;
+    void *ptr;
+
+    (void)len;
+
+    st = avformat_new_stream(ctx->s, NULL);
+    if (st == NULL)
+        return -ENOMEM;
+
+    stream_index = ctx->num_st++;
+    if (av_buffer_realloc(&ctx->st_data,
+                          ctx->num_st * sizeof(struct stream_ctx))
+        != 0) {
+        ctx->num_st = stream_index;
+        return -ENOMEM;
+    }
+    ptr = ctx->st_data->data;
+    sctx = ptr;
+    sctx[stream_index].comp_algo = -1;
+
+    st->id = val->uinteger;
+
+    st->codecpar = avcodec_parameters_alloc();
+    if (st->codecpar == NULL)
+        return -ENOMEM;
+
+    if (ctx->ts_scale.den != 0)
+        avpriv_set_pts_info(st, 64, ctx->ts_scale.num, ctx->ts_scale.den);
+    if (ctx->duration != -1)
+        st->duration = ctx->duration;
+
+    if (ctx->title != NULL) {
+        if (av_dict_set(&st->metadata, "title", ctx->title, 0) < 0) {
+            avcodec_parameters_free(&st->codecpar);
+            return -ENOMEM;
+        }
+        free(ctx->title);
+        ctx->title = NULL;
+    }
+
+    ctx->cur_st = st;
+
+    return 0;
+}
+
+#define ENTRY(track_typ, media_typ) [track_typ] = (media_typ) + 1
+
+static int
+handle_TrackType(matroska_metadata_t *val, size_t len,
+                 struct libmatroska_demux_ctx *ctx)
+{
+    enum AVMediaType *type;
+
+    static const enum AVMediaType codec_type_map[] = {
+        ENTRY(1, AVMEDIA_TYPE_VIDEO),
+        ENTRY(2, AVMEDIA_TYPE_AUDIO),
+        ENTRY(17, AVMEDIA_TYPE_SUBTITLE)
+    };
+
+    (void)len;
+
+    type = &ctx->cur_st->codecpar->codec_type;
+
+    if (val->uinteger < ARRAY_SIZE(codec_type_map)) {
+        enum AVMediaType typ = codec_type_map[val->uinteger];
+
+        *type = typ == 0 ? AVMEDIA_TYPE_UNKNOWN : typ - 1;
+    } else
+        *type = AVMEDIA_TYPE_UNKNOWN;
+
+    return 0;
+}
+
+#undef ENTRY
+
+static int
+handle_DefaultDuration(matroska_metadata_t *val, size_t len,
+                       struct libmatroska_demux_ctx *ctx)
+{
+    AVRational framerate;
+    AVStream *st = ctx->cur_st;
+
+    (void)len;
+
+    framerate.num = 1000000000;
+    framerate.den = val->uinteger;
+    st->avg_frame_rate = st->r_frame_rate = framerate;
+
+    return 0;
+}
+
+static int
+handle_CodecID(matroska_metadata_t *val, size_t len,
+               struct libmatroska_demux_ctx *ctx)
+{
+    const struct libmatroska_codec *codec;
+
+    (void)len;
+
+    codec = libmatroska_codec_id_find(val->data, val->len);
+    ctx->cur_st->codecpar->codec_id = codec == NULL
+                                      ? AV_CODEC_ID_NONE : codec->codec_id;
+
+    return 0;
+}
+
+static int
+handle_CodecPrivate(matroska_metadata_t *val, size_t len,
+                    struct libmatroska_demux_ctx *ctx)
+{
+    AVCodecParameters *codecpar;
+    uint8_t *extradata;
+
+    (void)len;
+
+    extradata = av_malloc(val->len + AV_INPUT_BUFFER_PADDING_SIZE);
+    if (extradata == NULL)
+        return -ENOMEM;
+
+    memcpy(extradata, val->data, val->len);
+    memset(extradata + val->len, 0, AV_INPUT_BUFFER_PADDING_SIZE);
+
+    codecpar = ctx->cur_st->codecpar;
+
+    codecpar->extradata = extradata;
+    codecpar->extradata_size = val->len;
+
+    return 0;
+}
+
+static int
+handle_PixelWidth(matroska_metadata_t *val, size_t len,
+                  struct libmatroska_demux_ctx *ctx)
+{
+    (void)len;
+
+    return handle_dimension(val, ctx->pdim, 0, ctx);
+}
+
+static int
+handle_PixelHeight(matroska_metadata_t *val, size_t len,
+                   struct libmatroska_demux_ctx *ctx)
+{
+    (void)len;
+
+    return handle_dimension(val, ctx->pdim, 1, ctx);
+}
+
+static int
+handle_DisplayWidth(matroska_metadata_t *val, size_t len,
+                    struct libmatroska_demux_ctx *ctx)
+{
+    (void)len;
+
+    return handle_dimension(val, ctx->ddim, 0, ctx);
+}
+
+static int
+handle_DisplayHeight(matroska_metadata_t *val, size_t len,
+                     struct libmatroska_demux_ctx *ctx)
+{
+    (void)len;
+
+    return handle_dimension(val, ctx->ddim, 1, ctx);
+}
+
+static int
+handle_SamplingFrequency(matroska_metadata_t *val, size_t len,
+                         struct libmatroska_demux_ctx *ctx)
+{
+    (void)len;
+
+    ctx->cur_st->codecpar->sample_rate = val->dbl;
+
+    return 0;
+}
+
+static int
+handle_Channels(matroska_metadata_t *val, size_t len,
+                struct libmatroska_demux_ctx *ctx)
+{
+    AVChannelLayout *ch;
+
+    (void)len;
+
+    ch = &ctx->cur_st->codecpar->ch_layout;
+    ch->order = AV_CHANNEL_ORDER_UNSPEC;
+    ch->nb_channels = val->uinteger;
+
+    return 0;
+}
+
+static int
+handle_BlockDuration(matroska_metadata_t *val, size_t len,
+                     struct libmatroska_demux_ctx *ctx)
+{
+    (void)len;
+
+    ctx->pkt_duration = val->uinteger;
+
+    return 0;
+}
+
+static int
+handle_ContentCompression(matroska_metadata_t *val, size_t len,
+                          struct libmatroska_demux_ctx *ctx)
+{
+    struct stream_ctx *sctx;
+    void *ptr;
+
+    (void)val;
+    (void)len;
+
+    ptr = ctx->st_data->data;
+
+    sctx = ptr;
+    sctx[ctx->cur_st->index].comp_algo = 0;
+
+    return 0;
+}
+
+#define POSSIBLE_MATCH(name, type) \
+    {#name, MATROSKA_TYPE_##type, &handle_##name}
+
+#define ENTRY(hash, name, type) \
+    [hash] = {POSSIBLE_MATCH(name, type)}
+
+static int
+metadata_cb(const char *id, matroska_metadata_t *val, size_t len, size_t hdrlen,
+            int flags, void *ctx)
+{
+    int err;
+    matroska_metadata_t full_val;
+    regmatch_t match[2];
+    size_t i;
+    struct libmatroska_demux_ctx *dctx = ctx;
+
+    static const struct ent {
+        const char                  *id;
+        enum matroska_metadata_type type;
+        metadata_handler_t          *fn;
+    } idtbl[64][2] = {
+        ENTRY(9,            TimestampScale,     UINTEGER),
+        ENTRY(1,            Duration,           DOUBLE),
+        ENTRY(4,            Title,              BYTES),
+        [28] = {
+            POSSIBLE_MATCH( Timestamp,          UINTEGER),
+            POSSIBLE_MATCH( ContentCompression, MASTER)
+        },
+        ENTRY(44,           TrackNumber,        UINTEGER),
+        ENTRY(8,            TrackType,          UINTEGER),
+        ENTRY(15,           DefaultDuration,    UINTEGER),
+        ENTRY(3,            CodecID,            BYTES),
+        [2] = {
+            POSSIBLE_MATCH( BlockDuration,      UINTEGER),
+            POSSIBLE_MATCH( CodecPrivate,       BYTES)
+        },
+        ENTRY(11,           PixelWidth,         UINTEGER),
+        ENTRY(13,           PixelHeight,        UINTEGER),
+        ENTRY(25,           DisplayWidth,       UINTEGER),
+        ENTRY(0,            DisplayHeight,      UINTEGER),
+        ENTRY(5,            SamplingFrequency,  DOUBLE),
+        ENTRY(60,           Channels,           UINTEGER)
+    };
+    const struct ent *ent;
+
+    (void)hdrlen;
+
+    if (flags & MATROSKA_METADATA_FLAG_HEADER)
+        return 0;
+
+    if (regexec(&dctx->id_regex, id, ARRAY_SIZE(match), match, 0) != 0)
+        return -EILSEQ;
+    id += match[1].rm_so;
+
+    if (flags & MATROSKA_METADATA_FLAG_FRAGMENT) {
+        if (strcmp(id, "Block") == 0 || strcmp(id, "SimpleBlock") == 0)
+            return 0;
+        if (dctx->buf == NULL) {
+            dctx->buf = malloc(len + 1);
+            if (dctx->buf == NULL)
+                return -errno;
+        }
+        memcpy(dctx->buf + dctx->len, val->data, val->len);
+        dctx->buf[dctx->len + val->len] = '\0';
+        dctx->len += val->len;
+        if (dctx->len < len)
+            return 0;
+        full_val.type = val->type;
+        full_val.data = dctx->buf;
+        full_val.len = len;
+        val = &full_val;
+    }
+
+    debug_printf("%s\n", id);
+
+    for (i = 0; i < ARRAY_SIZE(idtbl[0]); i++) {
+        ent = &idtbl[hash_id(id)][i];
+
+        if (ent->id != NULL && strcmp(ent->id, id) == 0) {
+            if (val->type != ent->type)
+                return -EIO;
+            err = (*ent->fn)(val, len, dctx);
+            if (err)
+                return err;
+        }
+    }
+
+    if (dctx->len == len) {
+        free(dctx->buf);
+        dctx->buf = NULL;
+        dctx->len = 0;
+    }
+
+    return 0;
+}
+
+#undef ENTRY
+
+#undef POSSIBLE_MATCH
+
+static int
+bitstream_cb(uint64_t trackno, const void *buf, size_t len, size_t framelen,
+             size_t totlen, size_t hdrlen, size_t num_logical_bytes,
+             int64_t off, int16_t ts, int new_frame, int keyframe, void *ctx)
+{
+    AVPacket *pkt;
+    struct libmatroska_demux_ctx *dctx = ctx;
+
+    (void)hdrlen;
+    (void)num_logical_bytes;
+    (void)new_frame;
+
+    debug_printf("Track %" PRIu64 ": %zu byte%s (total %zu byte%s), offset "
+                 "%" PRIi64 " byte%s%s\n",
+                 trackno, len, PLURAL(len, "s"), totlen, PLURAL(totlen, "s"),
+                 off, PLURAL(off, "s"), keyframe ? " (keyframe)" : "");
+
+    pkt = dctx->pkt;
+
+    if (pkt->buf == NULL) {
+        pkt->buf = av_buffer_alloc(totlen + AV_INPUT_BUFFER_PADDING_SIZE);
+        if (pkt->buf == NULL)
+            return -ENOMEM;
+        memset(pkt->buf->data + totlen, 0, AV_INPUT_BUFFER_PADDING_SIZE);
+        dctx->off = 0;
+
+#ifndef NO_TIMESTAMPS
+        pkt->pts = dctx->base_ts + ts;
+#endif
+        pkt->data = pkt->buf->data;
+        pkt->size = totlen;
+        pkt->stream_index = trackno - 1;
+        if (keyframe)
+            pkt->flags |= AV_PKT_FLAG_KEY;
+        pkt->pos = off;
+
+        fprintf(stderr, "Track %" PRIu64 ": %" PRIi64 " == %" PRIu64 " + %"
+                        PRIi16 " ms%s\n",
+                trackno, pkt->pts, dctx->base_ts, ts, keyframe ? " (I)" : "");
+    }
+
+    memcpy(pkt->buf->data + dctx->off, buf, len);
+    dctx->off += len;
+
+    return dctx->off == framelen;
+}
+
+static int
+zlib_stream_cb(const void *buf, size_t len, void *ctx)
+{
+    size_t newlen, newsz;
+    struct zlib_ctx *zctx = ctx;
+
+    newlen = zctx->len + len;
+
+    if (newlen > zctx->sz) {
+        newsz = newlen * 2;
+        if (av_buffer_realloc(&zctx->buf, newsz) != 0)
+            return -ENOMEM;
+        zctx->sz = newsz;
+    }
+
+    memcpy(zctx->buf->data + zctx->len, buf, len);
+
+    zctx->len = newlen;
+
+    return 0;
+}
+
+static int
+libmatroska_read_probe(const AVProbeData *p)
+{
+    (void)p;
+
+    return 0;
+}
+
+static int
+libmatroska_read_header(struct AVFormatContext *s)
+{
+    int err;
+    matroska_bitstream_cb_t cb;
+    matroska_io_fns_t fns;
+    matroska_metadata_cb_t metacb;
+    struct libmatroska_demux_ctx *ctx;
+
+    ctx = av_mallocz(sizeof(*ctx));
+    if (ctx == NULL)
+        return AVERROR(ENOMEM);
+
+    ctx->class = ff_libmatroska_demuxer.priv_class;
+
+    fns.open = &io_open;
+    fns.close = &io_close;
+    fns.read = &io_read;
+    fns.get_fpos = &io_get_fpos;
+
+    metacb.output_cb = &metadata_cb;
+    cb.output_cb = &bitstream_cb;
+    err = matroska_open(&ctx->hdl, &fns, &metacb, &cb,
+                        MATROSKA_OPEN_FLAG_RDONLY, s->pb, ctx);
+    if (err)
+        goto err1;
+
+    if (regcomp(&ctx->id_regex, "[^ ]+ +-> +([^ ]+)", REG_EXTENDED) != 0) {
+        err = -ENOMEM;
+        goto err2;
+    }
+
+    err = matroska_read_header(NULL, ctx->hdl, 0);
+    if (err)
+        goto err3;
+
+    ctx->s = s;
+
+    ctx->duration = -1;
+
+    ctx->pdim[0] = ctx->pdim[1] = -1;
+    ctx->ddim[0] = ctx->ddim[1] = -1;
+
+    ctx->st_data = NULL;
+    ctx->num_st = 0;
+
+    s->priv_data = ctx;
+    s->ctx_flags = AVFMTCTX_NOHEADER;
+    s->probesize = 64 * 1024 * 1024;
+
+    return 0;
+
+err3:
+    regfree(&ctx->id_regex);
+err2:
+    matroska_close(ctx->hdl);
+err1:
+    av_free(ctx);
+    return AVERROR(-err);
+}
+
+static int
+libmatroska_read_packet(struct AVFormatContext *s, AVPacket *pkt)
+{
+    int res;
+    size_t sz, tot_bytes;
+    struct libmatroska_demux_ctx *ctx = s->priv_data;
+    struct stream_ctx *sctx;
+    void *ptr;
+    zlib_stream_hdl_t hdl;
+
+    ctx->pkt = pkt;
+
+    ctx->pkt_duration = 0;
+
+    res = matroska_read_body(NULL, ctx->hdl, MATROSKA_READ_FLAG_MASTER);
+    if (res != 1)
+        return res == 0 ? AVERROR_EOF : AVERROR(-res);
+
+    pkt->duration = ctx->pkt_duration;
+
+    if (pkt->buf != NULL && pkt->stream_index < ARRAY_SIZE(ctx->tot_bytes)) {
+        sz = pkt->buf->size;
+        ctx->tot_bytes[pkt->stream_index] += sz;
+    } else
+        sz = 0;
+
+    tot_bytes = ctx->tot_bytes[pkt->stream_index];
+
+    debug_printf("Stream %d: %zu byte%s (%zu byte%s total)\n",
+                 pkt->stream_index, sz, PLURAL(sz, "s"), tot_bytes,
+                 PLURAL(tot_bytes, "s"));
+
+    (void)tot_bytes;
+
+    if (ctx->off != pkt->size) {
+        int64_t sz_error = ctx->off - pkt->size;
+
+        fprintf(stderr, "Synchronization error: offset %zu byte%s "
+                        "(%+" PRIi64 " byte%s)\n",
+                ctx->off, PLURAL(ctx->off, "s"), sz_error,
+                PLURAL(sz_error, "s"));
+        abort();
+    }
+
+    ptr = ctx->st_data->data;
+    sctx = ptr;
+
+    if (sctx[pkt->stream_index].comp_algo == 0
+        && ctx->s->streams[pkt->stream_index]->codecpar->codec_type
+           == AVMEDIA_TYPE_SUBTITLE) {
+        size_t remlen;
+        struct zlib_ctx zctx;
+
+        zctx.sz = pkt->size;
+        zctx.buf = av_buffer_alloc(zctx.sz);
+        if (zctx.buf == NULL)
+            return AVERROR(ENOMEM);
+        zctx.len = 0;
+
+        res = zlib_stream_init(&hdl, &zlib_stream_cb, &zctx);
+        if (res != 0)
+            return AVERROR(-res);
+
+        res = zlib_stream_inflate(hdl, pkt->data, pkt->size, &remlen);
+        if (res != 0 && res != 1) {
+            res = AVERROR(-res);
+            goto err;
+        }
+
+        zlib_stream_destroy(hdl);
+
+        res = av_buffer_realloc(&zctx.buf, zctx.len);
+        if (res != 0)
+            return res;
+
+        av_buffer_unref(&pkt->buf);
+        pkt->buf = zctx.buf;
+        pkt->data = pkt->buf->data;
+        pkt->size = zctx.len;
+    }
+
+    return 0;
+
+err:
+    zlib_stream_destroy(hdl);
+    return res;
+}
+
+static int
+libmatroska_read_close(struct AVFormatContext *s)
+{
+    int err;
+    struct libmatroska_demux_ctx *ctx = s->priv_data;
+
+    err = matroska_close(ctx->hdl);
+    regfree(&ctx->id_regex);
+    return err ? AVERROR(-err) : 0;
+}
+
+/* vi: set expandtab sw=4 ts=4: */
diff --git a/libavformat/libmatroska_codecs.gperf b/libavformat/libmatroska_codecs.gperf
new file mode 100644
index 0000000000..587aab3aa8
--- /dev/null
+++ b/libavformat/libmatroska_codecs.gperf
@@ -0,0 +1,77 @@
+%define lookup-function-name libmatroska_codec_id_find
+%struct-type
+%{
+#include "libmatroska_codecs.h"
+
+#include "libavcodec/codec_id.h"
+%}
+struct libmatroska_codec;
+%%
+V_MS/VFW/FOURCC,AV_CODEC_ID_NONE
+V_UNCOMPRESSED,AV_CODEC_ID_RAWVIDEO
+V_MPEG4/ISO/SP,AV_CODEC_ID_MPEG4
+V_MPEG4/ISO/ASP,AV_CODEC_ID_MPEG4
+V_MPEG4/ISO/AP,AV_CODEC_ID_MPEG4
+V_MPEG4/MS/V3,AV_CODEC_ID_MSMPEG4V3
+V_MPEG1,AV_CODEC_ID_MPEG2VIDEO
+V_MPEG2,AV_CODEC_ID_MPEG2VIDEO
+V_MPEG4/ISO/AVC,AV_CODEC_ID_H264
+V_MPEGH/ISO/HEVC,AV_CODEC_ID_HEVC
+V_AVS2,AV_CODEC_ID_AVS2
+V_REAL/RV10,AV_CODEC_ID_RV10
+V_REAL/RV20,AV_CODEC_ID_RV20
+V_REAL/RV30,AV_CODEC_ID_RV30
+V_REAL/RV40,AV_CODEC_ID_RV40
+V_QUICKTIME,AV_CODEC_ID_NONE
+V_THEORA,AV_CODEC_ID_THEORA
+V_PRORES,AV_CODEC_ID_PRORES
+V_VP8,AV_CODEC_ID_VP8
+V_VP9,AV_CODEC_ID_VP9
+V_FFV1,AV_CODEC_ID_FFV1
+A_MPEG/L3,AV_CODEC_ID_MP3
+A_MPEG/L2,AV_CODEC_ID_MP3
+A_MPEG/L1,AV_CODEC_ID_MP3
+A_PCM/INT/BIG,AV_CODEC_ID_NONE
+A_PCM/INT/LIT,AV_CODEC_ID_NONE
+A_PCM/FLOAT/IEEE,AV_CODEC_ID_NONE
+A_MPC,AV_CODEC_ID_MUSEPACK8
+A_AC3,AV_CODEC_ID_AC3
+A_AC3/BSID9,AV_CODEC_ID_AC3
+A_AC3/BSID10,AV_CODEC_ID_AC3
+A_ALAC,AV_CODEC_ID_ALAC
+A_DTS,AV_CODEC_ID_DTS
+A_DTS/EXPRESS,AV_CODEC_ID_DTS
+A_DTS/LOSSLESS,AV_CODEC_ID_DTS
+A_VORBIS,AV_CODEC_ID_VORBIS
+A_FLAC,AV_CODEC_ID_FLAC
+A_REAL/14_4,AV_CODEC_ID_RA_144
+A_REAL/28_8,AV_CODEC_ID_RA_288
+A_REAL/COOK,AV_CODEC_ID_COOK
+A_REAL/SIPR,AV_CODEC_ID_SIPR
+A_REAL/RALF,AV_CODEC_ID_RALF
+A_REAL/ATRC,AV_CODEC_ID_ATRAC3
+A_MS/ACM,AV_CODEC_ID_NONE
+A_AAC/MPEG2/MAIN,AV_CODEC_ID_AAC
+A_AAC/MPEG2/LC,AV_CODEC_ID_AAC
+A_AAC/MPEG2/LC/SBR,AV_CODEC_ID_AAC
+A_AAC/MPEG2/SSR,AV_CODEC_ID_AAC
+A_AAC/MPEG4/MAIN,AV_CODEC_ID_AAC
+A_AAC/MPEG4/LC,AV_CODEC_ID_AAC
+A_AAC/MPEG4/LC/SBR,AV_CODEC_ID_AAC
+A_AAC/MPEG4/SSR,AV_CODEC_ID_AAC
+A_AAC/MPEG4/LTP,AV_CODEC_ID_AAC
+A_QUICKTIME,AV_CODEC_ID_NONE
+A_QUICKTIME/QDMC,AV_CODEC_ID_QDMC
+A_QUICKTIME/QDM2,AV_CODEC_ID_QDM2
+A_TTA1,AV_CODEC_ID_TTA
+A_WAVPACK4,AV_CODEC_ID_WAVPACK
+S_TEXT/UTF8,AV_CODEC_ID_TEXT
+S_TEXT/SSA,AV_CODEC_ID_SSA
+S_TEXT/ASS,AV_CODEC_ID_ASS
+S_TEXT/WEBVTT,AV_CODEC_ID_WEBVTT
+S_IMAGE/BMP,AV_CODEC_ID_NONE
+S_DVBSUB,AV_CODEC_ID_DVB_SUBTITLE
+S_VOBSUB,AV_CODEC_ID_DVD_SUBTITLE
+S_HDMV/PGS,AV_CODEC_ID_HDMV_PGS_SUBTITLE
+S_HDMV/TEXTST,AV_CODEC_ID_HDMV_TEXT_SUBTITLE
+S_KATE,AV_CODEC_ID_NONE
diff --git a/libavformat/libmatroska_codecs.h b/libavformat/libmatroska_codecs.h
new file mode 100644
index 0000000000..b31e305825
--- /dev/null
+++ b/libavformat/libmatroska_codecs.h
@@ -0,0 +1,20 @@
+/*
+ * libmatroska_codecs.h
+ */
+
+#ifndef _MATROSKA_CODECS_H
+#define _MATROSKA_CODECS_H
+
+#include "libavcodec/codec_id.h"
+
+struct libmatroska_codec {
+    const char      *name;
+    enum AVCodecID  codec_id;
+};
+
+const struct libmatroska_codec *libmatroska_codec_id_find(const char *str,
+                                                          unsigned int len);
+
+#endif
+
+/* vi: set expandtab sw=4 ts=4: */
diff --git a/libavformat/zlib_stream.c b/libavformat/zlib_stream.c
new file mode 100644
index 0000000000..a70f56ccf2
--- /dev/null
+++ b/libavformat/zlib_stream.c
@@ -0,0 +1,131 @@
+/*
+ * zlib_stream.c
+ */
+
+#include "zlib_stream.h"
+
+#undef in
+#include <zlib.h>
+
+#include <errno.h>
+#include <stddef.h>
+#include <stdlib.h>
+
+#define BUFSZ 4096
+
+struct zlib_stream {
+    z_stream    s;
+    int         (*cb)(const void *, size_t, void *);
+    void        *ctx;
+    char        buf[BUFSZ];
+};
+
+#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
+
+static int xlat_zlib_err(int);
+
+#define ENTRY(zlib_err, err) [-zlib_err] = {.valid = 1, .ret = err}
+
+static int
+xlat_zlib_err(int err)
+{
+    static const struct ent {
+        unsigned    valid:1;
+        int         ret:31;
+    } errmap[] = {
+        ENTRY(Z_OK,             0),
+        ENTRY(Z_MEM_ERROR,      -ENOMEM),
+        ENTRY(Z_VERSION_ERROR,  -EPROTONOSUPPORT),
+        ENTRY(Z_STREAM_ERROR,   -EINVAL)
+    };
+    const struct ent *ent;
+
+    if (err >= (int)ARRAY_SIZE(errmap))
+        return -EIO;
+
+    ent = &errmap[-err];
+    return ent->valid ? ent->ret : -EIO;
+}
+
+#undef ENTRY
+
+int
+zlib_stream_init(zlib_stream_hdl_t *hdl,
+                 int (*cb)(const void *, size_t, void *), void *ctx)
+{
+    struct zlib_stream *ret;
+
+    ret = malloc(sizeof(*ret));
+    if (ret == NULL)
+        return -errno;
+
+    ret->s.next_in = NULL;
+
+    ret->s.zalloc = Z_NULL;
+    ret->s.zfree = Z_NULL;
+    ret->s.opaque = Z_NULL;
+
+    ret->cb = cb;
+    ret->ctx = ctx;
+
+    *hdl = ret;
+    return 0;
+}
+
+int
+zlib_stream_destroy(zlib_stream_hdl_t hdl)
+{
+    int ret;
+
+    ret = inflateEnd(&hdl->s);
+
+    free(hdl);
+
+    return ret == Z_OK ? 0 : -EIO;
+}
+
+int
+zlib_stream_inflate(zlib_stream_hdl_t hdl, void *buf, size_t len,
+                    size_t *remlen)
+{
+    int end;
+    int first;
+    int ret;
+
+    first = hdl->s.next_in == NULL;
+
+    hdl->s.next_in = buf;
+    hdl->s.avail_in = len;
+
+    if (first) {
+        ret = inflateInit(&hdl->s);
+        if (ret != Z_OK)
+            return xlat_zlib_err(ret);
+    }
+
+    for (;;) {
+        hdl->s.next_out = (unsigned char *)hdl->buf;
+        hdl->s.avail_out = sizeof(hdl->buf);
+
+        ret = inflate(&hdl->s, Z_NO_FLUSH);
+        if (ret != Z_OK) {
+            end = ret == Z_STREAM_END;
+            if (!end)
+                return xlat_zlib_err(ret);
+        } else
+            end = 0;
+
+        ret = (*hdl->cb)(hdl->buf, (char *)hdl->s.next_out - hdl->buf,
+                         hdl->ctx);
+        if (ret != 0)
+            return ret;
+
+        if (end || hdl->s.avail_in == 0)
+            break;
+    }
+
+    *remlen = hdl->s.avail_in;
+    return end;
+}
+
+/* vi: set expandtab sw=4 ts=4: */
diff --git a/libavformat/zlib_stream.h b/libavformat/zlib_stream.h
new file mode 100644
index 0000000000..df1c366b8d
--- /dev/null
+++ b/libavformat/zlib_stream.h
@@ -0,0 +1,22 @@
+/*
+ * zlib_stream.h
+ */
+
+#ifndef _ZLIB_STREAM_H
+#define _ZLIB_STREAM_H
+
+#include <stddef.h>
+
+typedef struct zlib_stream *zlib_stream_hdl_t;
+
+int zlib_stream_init(zlib_stream_hdl_t *hdl,
+                     int (*cb)(const void *, size_t, void *), void *ctx);
+
+int zlib_stream_destroy(zlib_stream_hdl_t hdl);
+
+int zlib_stream_inflate(zlib_stream_hdl_t hdl, void *buf, size_t len,
+                        size_t *remlen);
+
+#endif
+
+/* vi: set expandtab sw=4 ts=4: */
diff --git a/tools/.gitignore b/tools/.gitignore
index 7c45896923..a54b8925c7 100644
--- a/tools/.gitignore
+++ b/tools/.gitignore
@@ -10,6 +10,7 @@
 /ffhash
 /graph2dot
 /ismindex
+/mkv_decode
 /pktdumper
 /probetest
 /qt-faststart
diff --git a/tools/mkv_decode.c b/tools/mkv_decode.c
new file mode 100644
index 0000000000..2d522ff2de
--- /dev/null
+++ b/tools/mkv_decode.c
@@ -0,0 +1,243 @@
+/*
+ * mkv_decode.c
+ *
+ * Based on tools/decode_simple.c in FFmpeg distribution
+ */
+
+#include "libavcodec/avcodec.h"
+#include "libavcodec/packet.h"
+
+#include "libavformat/avformat.h"
+
+#include "libavutil/frame.h"
+
+#include <errno.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+struct decode_ctx {
+    AVFormatContext *fmt;
+    AVStream        *st;
+    int             stream_idx;
+    AVCodecContext  *codec;
+    AVPacket        *pkt;
+    AVFrame         *frame;
+};
+
+static int decode_cb(AVFrame *, void *);
+
+static int init_decode_ctx(struct decode_ctx *, const char *, int);
+static void destroy_decode_ctx(struct decode_ctx *);
+
+static int receive_frames(struct decode_ctx *, int (*)(AVFrame *, void *),
+                          void *);
+
+static int process_decode(struct decode_ctx *, int (*)(AVFrame *, void *),
+                          void *);
+
+static int
+decode_cb(AVFrame *frame, void *ctx)
+{
+    (void)ctx;
+
+    if (frame != NULL) {
+        fprintf(stderr, "Coded picture number %d\n",
+                frame->coded_picture_number);
+    }
+
+    return 0;
+}
+
+static int
+init_decode_ctx(struct decode_ctx *ctx, const char *url, int stream_idx)
+{
+    const AVInputFormat *fmt;
+    int ret;
+
+    fmt = av_find_input_format("libmatroska");
+    if (fmt == NULL)
+        return -EIO;
+
+    ctx->fmt = NULL;
+    ret = avformat_open_input(&ctx->fmt, url, fmt, NULL);
+    if (ret != 0)
+        return ret;
+
+    ctx->stream_idx = stream_idx;
+
+    ctx->pkt = av_packet_alloc();
+    if (ctx->pkt == NULL) {
+        ret = -ENOMEM;
+        goto err1;
+    }
+
+    ctx->frame = av_frame_alloc();
+    if (ctx->frame == NULL) {
+        ret = -ENOMEM;
+        goto err2;
+    }
+
+    return 0;
+
+err2:
+    av_packet_free(&ctx->pkt);
+err1:
+    avformat_close_input(&ctx->fmt);
+    return ret;
+}
+
+static void
+destroy_decode_ctx(struct decode_ctx *ctx)
+{
+    av_frame_free(&ctx->frame);
+    av_packet_free(&ctx->pkt);
+
+    avformat_close_input(&ctx->fmt);
+}
+
+static int
+receive_frames(struct decode_ctx *dctx, int (*cb)(AVFrame *, void *), void *ctx)
+{
+    int ret;
+
+    for (;;) {
+        ret = avcodec_receive_frame(dctx->codec, dctx->frame);
+        if (ret != 0) {
+            if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)
+                break;
+            return ret;
+        }
+
+        ret = (*cb)(dctx->frame, ctx);
+        av_frame_unref(dctx->frame);
+        if (ret != 0)
+            return ret;
+    }
+
+    return 0;
+}
+
+static int
+process_decode(struct decode_ctx *dctx, int (*cb)(AVFrame *, void *), void *ctx)
+{
+    const AVCodec *codec;
+    int init = 0;
+    int ret, tmp;
+
+    ret = av_read_frame(dctx->fmt, dctx->pkt);
+    if (ret != 0)
+        return ret == AVERROR_EOF ? 0 : -EIO;
+
+    if (dctx->stream_idx >= dctx->fmt->nb_streams)
+        return -EINVAL;
+    dctx->st = dctx->fmt->streams[dctx->stream_idx];
+
+    codec = avcodec_find_decoder(dctx->st->codecpar->codec_id);
+    if (codec == NULL)
+        return -EPROTO;
+
+    dctx->codec = avcodec_alloc_context3(codec);
+    if (dctx->codec == NULL)
+        return -ENOMEM;
+
+    if (dctx->pkt->stream_index == dctx->st->index) {
+        ret = avcodec_parameters_to_context(dctx->codec, dctx->st->codecpar);
+        if (ret != 0)
+            return -EIO;
+
+        if (avcodec_open2(dctx->codec, NULL, NULL) != 0) {
+            avcodec_free_context(&dctx->codec);
+            return -ENOMEM;
+        }
+
+        init = 1;
+
+        ret = avcodec_send_packet(dctx->codec, dctx->pkt);
+        av_packet_unref(dctx->pkt);
+        if (ret != 0) {
+            ret = -EIO;
+            goto end;
+        }
+
+        ret = receive_frames(dctx, cb, ctx);
+        if (ret != 0)
+            goto end;
+    } else
+        av_packet_unref(dctx->pkt);
+
+    for (;;) {
+        ret = av_read_frame(dctx->fmt, dctx->pkt);
+        if (ret != 0) {
+            if (ret == AVERROR_EOF)
+                ret = 0;
+            break;
+        }
+        if (dctx->pkt->stream_index != dctx->st->index) {
+            av_packet_unref(dctx->pkt);
+            continue;
+        }
+
+        if (!init) {
+            ret = avcodec_parameters_to_context(dctx->codec,
+                                                dctx->st->codecpar);
+            if (ret != 0)
+                return -EIO;
+
+            if (avcodec_open2(dctx->codec, NULL, NULL) != 0) {
+                avcodec_free_context(&dctx->codec);
+                return -ENOMEM;
+            }
+
+            init = 1;
+        }
+
+        ret = avcodec_send_packet(dctx->codec, dctx->pkt);
+        av_packet_unref(dctx->pkt);
+        if (ret != 0)
+            break;
+
+        ret = receive_frames(dctx, cb, ctx);
+        if (ret != 0)
+            break;
+    }
+
+end:
+    if (init) {
+        avcodec_send_packet(dctx->codec, NULL);
+        tmp = receive_frames(dctx, cb, ctx);
+        avcodec_close(dctx->codec);
+        if (tmp != 0)
+            return tmp;
+    }
+    return ret;
+}
+
+int
+main(int argc, char **argv)
+{
+    const char *url;
+    int ret;
+    int stream_idx;
+    struct decode_ctx ctx;
+
+    if (argc < 3) {
+        fputs("Must specify URL and stream index\n", stderr);
+        return EXIT_FAILURE;
+    }
+    url = argv[1];
+    stream_idx = atoi(argv[2]);
+
+    if (init_decode_ctx(&ctx, url, stream_idx) != 0) {
+        fprintf(stderr, "Error opening %s\n", url);
+        return EXIT_FAILURE;
+    }
+
+    ret = process_decode(&ctx, &decode_cb, NULL);
+
+    destroy_decode_ctx(&ctx);
+
+    return ret == 0 ? EXIT_SUCCESS : EXIT_FAILURE;
+}
+
+/* vi: set expandtab sw=4 ts=4: */
