/*
 * errc.c
 */

#include "std_sys.h"
#include "util.h"

#define NO_ASSERT_MACROS
#include "common.h"
#undef NO_ASSERT_MACROS

#include <errno.h>
#include <limits.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define MAX_LOOKUP_TBL_SZ 512

static void do_printf(const char *, ...);

static void
do_printf(const char *fmt, ...)
{
    int ret;
    va_list ap;

    va_start(ap, fmt);
    ret = vprintf(fmt, ap);
    va_end(ap);

    if (ret < 0) {
        fputs("Error writing output\n", stderr);
        exit(EXIT_FAILURE);
    }
}

int
main(int argc, char **argv)
{
    const struct ent *ent;
    int errn;
    int i;
    int lookup_tbl;
    int max_errn, min_errn;
    int num_errn;
    int tmp;
    size_t idx, startidx;

    static const struct ent {
        int         src;
        int         dst;
        const char  *srcnm;
        const char  *dstnm;
    } errlist[] = {
#define X(nm, no) \
        {E##nm, SYS_E##nm, STR_NO_EVAL(E##nm), STR_NO_EVAL(SYS_E##nm)},
        LIST_ERRNO(X)
#undef X
    };

#define X(nm, no) + 1
    static int errtbl[LIST_ERRNO(X)];
#undef X

    (void)argc;
    (void)argv;

    num_errn = ARRAY_SIZE(errlist);
    if (num_errn == 0)
        return EXIT_SUCCESS;

    min_errn = INT_MAX;
    max_errn = INT_MIN;
    for (i = 0; i < num_errn; i++) {
        ent = &errlist[i];

        errn = ent->src;
        if (errn < min_errn)
            min_errn = errn;
        if (errn > max_errn)
            max_errn = errn;
    }

    if (setvbuf(stdout, NULL, _IOLBF, 0) == EOF) {
        fputs("Out of memory\n", stderr);
        return EXIT_FAILURE;
    }

    do_printf("/* Note: File generated by errc */\n\n");

    do_printf("#include \"debug.h\"\n\n");
    do_printf("#include \"err.h\"\n\n");

    lookup_tbl = max_errn - min_errn < MAX_LOOKUP_TBL_SZ;

    do_printf("#define %s 1\n\n", lookup_tbl ? "ERRTBL" : "ERRMAP");

    do_printf("const int min_errn = %d;\n\n", min_errn);

    tmp = num_errn - 1;

    do_printf("GCC_DIAGNOSTIC_PUSH()\n"
              "GCC_DIAGNOSTIC_IGNORED(initializer_overrides)\n"
              "GCC_DIAGNOSTIC_IGNORED(override_init)\n\n");

    do_printf("const int errtbl[] = {\n");

    if (lookup_tbl) {
        for (i = 0; i <= tmp; i++) {
            ent = &errlist[i];

            errn = ent->src;

            do_printf("\t[%3d] = %3d%s /* %s */\n",
                      errn - min_errn, ent->dst, i == tmp ? " " : ",",
                      ent->dstnm);
        }
    } else
        do_printf("\t0");

    do_printf("\n};\n\n");

    do_printf("const struct errmap_ent errmap[] = {\n");

    if (!lookup_tbl) {
        for (i = 0; i <= tmp; i++) {
            ent = &errlist[i];

            errn = ent->src;

            idx = startidx = (errn - min_errn) % num_errn;
            for (;;) {
                if (errtbl[idx] == 0)
                    break;
                idx = (idx + 1) % num_errn;
                if (idx == startidx)
                    abort();
            }
            errtbl[idx] = errn;

            do_printf("\t[%3zu] = {%3d, %3d}%s /* %s */\n",
                      idx, errn, ent->dst, i == tmp ? " " : ",", ent->dstnm);
        }
    } else
        do_printf("\t{0, 0}");

    do_printf("\n};\n\n");

    do_printf("const int errmapr[] = {\n");

    for (i = 0; i <= tmp; i++) {
        ent = &errlist[i];

        do_printf("\t[%3d] = %3d%s /* %s */\n",
                  ent->dst, ent->src, i == tmp ? " " : ",", ent->srcnm);
    }

    do_printf("\n};\n\n");

    do_printf("GCC_DIAGNOSTIC_POP()\n\n");

    if (fflush(stdout) == EOF)
        goto err;

    tmp = fileno(stdout);
    while (fsync(tmp) == -1) {
        if (errno != EINTR) {
            if (errno != EBADF && errno != EINVAL && errno != ENOTSUP)
                goto err;
            break;
        }
    }

    return EXIT_SUCCESS;

err:
    fputs("Error writing output\n", stderr);
    return EXIT_FAILURE;
}

/* vi: set expandtab sw=4 ts=4: */
